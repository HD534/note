# Chapter 12 通过异常处理错误
## 1 概念
java 使用异常来提供一致的错误报告模型。

## 2 基本异常
异常情形（exceptional condition）是指阻止当前方法或作用域继续执行的问题，把异常情形与普通问题区分很重要。
普通问题是指在当前环境下能够得到足够的信息来处理这个错误。
异常情形就不能继续下去了，因为在当前环境下无法获得不要的信息来解决问题，你所能做的就是把问题交给上一个环境，这就是抛出异常。

除法是一个简单的例子，除数有可能为0，所以有必要进行检查，但是除数为0的情况，通过当前的环境不能够处理，所以就要抛出异常，而不是继续执行下去。

抛出异常后，Java将使用 `new` 在堆上建立异常对象，然后当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用。
此时，异常处理机制接管程序，并开始寻找一个恰当的地方来执行程序。这个恰当的地方就是**异常处理程序**。它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。
一个抛出异常的例子，对于一个对象引用，如果未初始化的，那么进行检查后创建一个代表错误信息的对象，并且从当前环境抛出。
```
if(t==null){
	throw new NullPointerException();
}
```
这就抛出了异常，当前环境不必为这个问题再操心。

异常可以看作是程序的恢复系统，我们的程序可以有多个不同恢复点，如果程序某部分失败了，异常将”恢复“到程序的某个已知的稳定点。

### 2.1 异常参数
用 new 在堆上创建异常对象，也伴随着存储空间的分配和构造器的调用，标准异常的构造器一个是默认构造器，一个是接收字符串作为参数，以便放置相关信息。
```
throw new NullPointerException("t = null");
```

new 创建对象之后，此对象引用将传给 throw ，方法的返回与异常的抛出不同，但从效果上看可以把异常抛出类似方法”返回“。
另外异常的抛出会退出当前的方法或作用域。

此外，能够抛出任意类型的 Throwable 对象，它是异常的根类。通常不同的错误对应不同的异常，错误信息保存在异常对象内部或通过异常类的名称暗示。

## 3 捕获异常
要明白异常是如何被捕获的，首先要理解监控区域（guarded region）的概念，它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。

### 3.1 try 块
如果在方法内部抛出异常或者调用的其他方法抛出异常，这个方法将在抛出异常的过程中结束，如果添加一个 try 块，就可以在这个块里”尝试“各种可能产生方法的调用。
```
try{
	// 可能会产生异常的代码
}
```
有了异常处理机制，就可以在一个地方捕获所有异常，这样可以更容易编写和阅读代码，因为完成任务的代码与错误检查的代码分离开。

### 3.2 异常处理程序
抛出的异常必须在某处得到处理，这个地点就是异常处理程序，而且可以针对每个异常类型准备相应的处理程序。
```
try{
	// 可能会产生异常的代码
}catch(Type1 id1){
	//处理的代码
}catch(Type2 id2){

}
```
每一个catch 子句（异常处理程序）看起来就像是接受一个且仅接受一个特殊类型的参数的方法。可以在内部使用标识符（id1，id2）。
异常处理程序必须紧跟在 try 块后，当异常被抛出时，异常粗合理机制复杂搜寻参数**与异常类型相匹配**的**第一个**处理程序，然后进入 catch 子句，此时认为异常得到了处理。
一旦 catch 子句结束，则处理程序的查找过程结束。
注意，只有匹配的 catch 子句才能得到执行，这与 switch 语句不同。
在 try 块的内部，许多不同方法的调用可能会产生类型相同的异常，而你只需要提供一个针对此类型的异常处理程序。

##### 终止与恢复
异常处理理论上有两种模型。
1. Java 支持终止模型，一旦异常被抛出，就表明错误无法挽回，此次操作无法再回来继续执行。
2. 恢复模型，修正错误，然后重新尝试调用出问题的方法。

对于恢复模型，通常是希望异常被处理之后能继续执行，如果在Java 中想实现类似恢复的行为，那么可以在遇见异常时不抛出，而是调用方法修改错误，或者把 `try` 块放在 `while` 循环里不断尝试直到得到满意的结果。

尽管可以实现恢复模型，但是终止模型的还是得到更多的使用。
主要原因是恢复模型所导致的耦合：
恢复性的处理程序需要了解异常抛出的地点，这就会在抛出的地点包含非通用性的代码，这与导致代码难以编写和维护，特别是对于可能会从许多地方抛出异常的大型程序。

## 4 自定义异常
Java 提供的异常体系不可能预见所有错误，所以可以自己定义异常类来表示程序中会遇到的特定问题。
自定义异常要继承现有的异常类。
```

class SimpleException extends Exception{}

public class SimpleExceptionTest  {
    void f() throws SimpleException {
        System.out.println("throw SimpleException");
        throw new SimpleException();
    }

    public static void main(String[] args) {
        SimpleExceptionTest simpleExceptionTest = new SimpleExceptionTest();
        try {
            simpleExceptionTest.f();
        } catch (SimpleException e) {
            e.printStackTrace();
        }
    }
}
```
创建的默认构造器调用基类的默认构造器，对异常来说，最重要的部分就是类型。

```
class MyException extends Exception{
    public MyException() {
    }

    public MyException(String message) {
        super(message);
    }
}
```
可以新增带参的构造器，使用 super 关键字明确基类构造器。


## 5 异常说明
异常说明使你可以告知代码的调用者某个方法可能会抛出的异常类型。它属于方法声明的一部分，紧跟在形式参数列表后。
异常说明使用了附加的关键字 throws ，后面接一个所有潜在异常的列表：
```
void f() throws ExceptionA, ExceptionB {
	//
}
```
但是如果不写抛出的异常
```
void f() {}
```
那就表明它不会抛出异常，除了那些继承自 RuntimeException 的异常，它们可以在没有异常说明的情况下抛出。

代码必须与异常说明一致，如果某个方法产生了异常却没有处理，编译器会让你要么处理这个异常，要么在异常列表说明此方法会抛出异常。
当然可以先声明方法先抛出异常，但实际不抛出，编译器会相信这个说明，并强制此方法的用户像真的抛出异常那样使用这个方法。
这样做的好处是，为异常先占个位置，以后抛出这种异常就不用修改已有的代码。在定义抽象基类和接口时这种能力很重要，这样派生类或接口实现就能够抛出这些预先声明的异常。
这种在编译时被强制检查的异常被称为 被检查的异常 (checked exceptions)。

## 6 捕获所有异常
通过捕获异常类的基类 `Exception` ，可以捕获所有类型的异常
```
catch (Exception e){ //... }
```
最好把它放在处理程序列表的末尾，以防止它抢在其他处理程序之前把异常捕获。

### 1 栈轨迹
printStackTrace() 提供的信息可以通过 getStackTrace() 方法来直接访问。这个返回返回一个有栈轨迹中的元素构成的数组，其中的每一个元素都表示栈中的一帧。

```
// ...
catch(Exception e){
	for(StackTraceElement  ste : e.getStackTrace()){
		System.out.println(ste.getMethodName());
	}
}
```

### 2 重新抛出异常
有时候希望把捕获的异常重新抛出。
```
catch(Exception e){
	throw e;
}
```
重新抛出异常会把异常抛给上一级环境中的异常处理程序，同一个catch 的后续子句会被忽略。此外异常的信息都得以保存。

如果重新抛出一个新的异常，那么抛出点就变成重新抛出异常的地方。

## 7 Java 标准异常
Throwable 类用来表示任何可以作为异常被抛出的类。 Throwable 对象分为两种，Error 用来表示编译时和系统错误， Exception 是可以被抛出的异常，在 java 雷克雅、用户方法以及运行时故障都可能抛出 Exception 型异常。 

### 1 特例： RuntimeException
运行时异常会自动被虚拟机抛出，所以不必在异常说明中列出来，它们也被称作 不受检查异常 (unchecked exceptions)。这种异常属于错误，将被自动捕获。尽管可以不用捕获 RuntimeException ，但还是可以在代码中抛出这种异常。
RumtimeException 如果没有被捕获会直达 main() ，在程序退出前将调用 printStackTrace() 方法。
RuntimeException 代表的是编程错误，例如 null ，或者数组越界。

## 8 使用 finally 进行清理
对于一些代码，可能希望无论try 中异常是否抛出都能够执行，这通常适用于 内存回收之外的情况（内存回收由垃圾回收器完成），可以用 finally 子句。
```
try{
	//
} catch (Exception e){
	//
} finally {
	//
}
```

### 1 finally 可以用来做什么
当要把除内存外的资源恢复到初始状态，例如已经打开的文件或网络，或者某个外部世界的开关等等，需要使用 finally 子句。

### 2 在 return 中使用 finally
finally 子句总是会被执行，所以可以在try 块中执行return，但是在 finally 中执行的 return 会覆盖之前的值（如果 return 有返回值的话）。

### 3 异常丢失
在 finally 中 return 的话，异常会丢失。
```
try{
	throw new RuntimeException();
} finally {
	// 异常丢失，程序直接返回。
	return ;
}
```

如果在 finally 中执行的语句会抛出异常，那么finally 之前抛出的异常会丢失。

##  9 异常的限制
当覆盖方法时，需要抛出基类方法说明的那些异常，这个限制意味着，当基类使用的代码应用到其派生类对象时，一样能够工作。

子类构造器的异常说明必须包含父类构造器的异常说明。

## 10 构造器


## 11 异常匹配
异常处理系统按照代码的书写顺序找到最近的处理程序，查找时并不需要异常完全匹配，子类异常对象也可以匹配父类的处理程序。所以处理 Exception 类的程序可以匹配所以编程时的异常。

如果处理父类异常的程序放在了处理子类异常的程序之前，那么编译器会报错，因为处理父类异常的程序”屏蔽“了子类异常的处理程序

## 12  其他可选方式
异常处理的一个重要原则是，只要在你直到如何处理的情况下才捕获异常，实际上，异常处理的一个重要目标就是把错误处理的代码和错误发生的地点分离，这样你在一段代码专注于要完成的事情，至于错误处理，则放在另外一段代码中。

被检查异常会强制你使用 catch 处理异常，这样可能会造成代码吞食了异常而不做处理（例如只是catch 住，但是没有代码进行处理）。

#### 把 被检查的异常 转换为 不检查的异常
JDK 1.4 的异常链提供了一种思路，当你需要捕获一种异常但是不想把它吞了或者打印一些无用的信息，可以将它包装进 RuntimeException 中，这样异常链保存不会丢失原始的异常信息。
```
try {
	//...
}catch (IDontKnowWhatToDoException e){
	throw new RuntimeException(e);
}
```

也可以创建自己的 RuntimeException 的子类，这样代码中不必捕获它，但是希望得到它的代码可以捕获它。


