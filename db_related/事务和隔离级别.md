## 事务和隔离级别
 
### 事务简介 ###

事务是一个单元，可能包含查询、修改数据、修改数据定义等多个活动。我们可以显式或隐式的定义事务边界。可以使用begin tran或者begin transaction语句显式的定义事务的开始。如果希望提交事务，可以使用commit tran语句显式的定义事务结束。如果不希望提交事务（即要撤销更改），可以使用rollback tran或者rollback transaction语句。
如果不显式的标记事务的边界，默认情况下，sql server将把每个单独语句作为一个事务，换句话说，默认情况下，每个单独语句结束后sql server自动提交事务。
可以通过一个叫做implicit_transactions的回话选项修改sql server处理隐式事务的方式，此选项默认为off。当此选项为on时，不需要指定begin tran语句标记事务的开始，但是必须以commit tran或者rollback tran语句标记事务的结束。

#### 事务特征 ####
事务具有原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持续性（durability）四个属性，缩写字母为acid。
1. 原子性：事务是一个工作单元，事务中的所有修改要么提交、要么撤销，在事务完成之前如果系统出现故障，重新启动时sql server会撤销所做的修改。
2. 一致性：一致性是指数据的状态，rdms提供了以并发事务修改和查询数据的能力。（ relational data (base) management system,关系数据（库）管理系统）
3. 隔离性：隔离是用于控制访问数据的机制，确保事务所访问数据是在其期望的一致性级别中的数据，sql server支持两种不同的模式来处理隔离：基于锁的传统模式和基于行版本控制的新模式，在企业内部部署的sql server中，默认是基于锁的模式。
4. 持续性：数据修改写入到数据库磁盘上的数据部分之前，总是先写入到数据库的事务日志磁盘，在提交之后，指令记录在事务日志的磁盘上，在尚未修改磁盘上的数据部分之前，事务被认为是持续的，在系统正常或是出现故障启动时，sql server将检查每个数据库的事务日志并执行具有两个阶段的恢复过程-重做和撤销。

![](https://blog.sqlauthority.com/i/c/acid.png)
<!-- ![](https://images2015.cnblogs.com/blog/589642/201701/589642-20170127170928566-1558732354.png) -->


说到事务，就得提到并发，为了解决事务中的并发，不得不讨论锁。
#### 锁的模式-排它锁和共享锁

- 排他锁：当试图修改数据时，事务会请求数据资源的一个排他锁，而不管其隔离级别，如果授予了锁，那么直到事务结束排他锁才会被解除，对于单语句事务意味着直到语句完成，锁定才会被解除，对于多语句事务意味着直到完成所有语句并通过commit tran或rollback tran命令结束才会解除锁定。排他锁之所以被称为排他，是因为如果一个事务正在修改行，直到事务完成，其他事务都不能修改相同的行，这是默认的修改行为。然而，另外一个事务能不能读取相同的行，取决于它的隔离级别。

- 共享锁:  当试图读取数据时，事务默认请求数据资源的一个共享锁，并且一旦语句完成资源读取，会立即释放资源的共享锁。共享锁之所以被称为共享，是因为多个事务可以同时持有相同资源的共享锁。虽然在修改数据时，不能修改锁的模式和所需的持续时间，但是通过改变其隔离级别，可以在读取数据时控制锁定的处理方式

排他锁和共享锁不能兼容，即相同的数据不能同时有排它锁和共享锁。
锁的存在会导致，更新行时会获取该资源的排它锁，如果更新成功，sql server会将锁授予会话，直到事务完成，所以该资源的排它锁一直存在。当读取数据需要获得资源的共享锁时，由于更新行会话一直存在即以排它锁的模式锁定，读取就会一直阻塞，因为共享锁和排它锁不能兼容。

#### 锁的隔离级别 ####
隔离级别确定了并发用户读取或写入的行为，读取者是任何选择数据的语句，默认情况下使用共享锁，写入者是任何对表进行修改的语句，并且需要一个排他锁。在获得锁和锁的持续期间，不能控制写入者的行为方式，但是可以控制读取者的行为方式。我们通过设置隔离级别来隐式的影响写入者的行为。

sql server支持4个基于悲观并发控制的传统隔离级别：`read uncommitted`、`read committed`（企业内部部署的sql server实例的默认方式）、`repeatable read`、`serializable`。sql server还支持两种基于并发控制（行版本）的隔离级别：`snapshot`和`read committed snapshot`（sql database的默认方式）在某种意义上，`snapshot`和`read committed snapshot`分别是`read committed`和`serializable`的乐观并发对应方式。

我们使用如下命令来设置整个会话的隔离级别
```
set transaction isolation level <isolation name>
```
或者间接在表查询中设置查询的隔离级别。
```
select ....  from table with(<isolationname>)
```
对于以上四个隔离级别，隔离级别越高，读取者请求的锁就越强，并且持续时间越长。因此，隔离级别越高，一致性越高，并发性越低，当然，反过来也是如此。  
对于两个基于快照的隔离级别，sql server能够在tempdb中存储之前提交的行版本，读取者不请求共享锁。相反，如果当前的行版本不是他们应该看到的，sql server将提供给他们一个较旧的版本。

1. read uncommitted 隔离级别
`read uncommitted` 是最低隔离级别，在该隔离级别中，读取者不需要请求共享锁，不要求共享锁的读取者从不会与持有排他锁的写入者发生冲突。**这意味着读取者可以读取未提交的更改即脏读**，也就是说，读取者不会干扰要求了排他锁的写入者，在该隔离级别下运行的读取者读取数据时，写入者可以更改数据。脏读即是读取事务可以读到其他修改事务未提交的数据更改。
`read uncommitted` ：在该隔离级别下会导致数据脏读。

2. `read committed` 隔离级别
如果想阻止读取者未提交的修改，则需要使用更高的隔离级别，防止脏读的最低的隔离级别为 `read committed` ，它是企业内部部署的 `sql server` 默认隔离级别，如名称所述，该隔离级别仅允许读取已提交的更改。  
它通过要求读取者获得一个共享锁来防止未提交的读取，也就是说，如果一个写入者持有了排他锁，读取者的共享锁请求将会与写入者冲突，此时必须等待，一旦写入者提交了事务，读取者就可以获得它的共享锁，所以它必然是只读取提交后的修改。  
   - 与 `read uncommitted` 隔离级别不同的是，在 `read committed` 隔离级别中，不会发生脏读，因为它只能读取已提交的修改，但是写入者未进行提交时会导致持续等待。对于读取者而言，它仅持有共享锁，它不会到事务结束一直持有锁，它甚至不会到语句结束，换句话说，在同一事务中的两次相同数据资源的读取之间，不会持有该资源的锁，所以其他事务可以在这两次读取的间隙修改资源，并且读取者每次读取到的值可能会有所不同，这种现象被称为不可重复读取或不一致解析。此时我们就必须通过更高的隔离级别来解决不可重复读取的问题。  
  
   -  同时我们需要注意的是在 `read committed` 隔离级别中可能出现【丢失更新】现象，丢失更新主要发生在两个事务读取一个值时，同时基于读取的值进行更新，由于在该隔离级别中读取后不会再该资源上持有锁，两个事务都可以更新其值，并且最后更新该值的事务将会覆盖另外一个事务的更新。

1. `repeatable read` 隔离级别
如果我们希望确保在同一事务中的多次读取之间没有其他事务能够修改其值，需要提升隔离级别到 `repeatable read` 。在该隔离级别中，读取者不仅需要一个共享锁才能够进行读取，而且直到事务结束都持有锁，这意味着只要读取者获得了数据资源上的共享锁，直到读取者结束事务，都没有其他事务可以获取一个排他锁来修改资源，这样才能保证可重复读取或者是一致的解析
- 虽然 `repeatable read`  隔离级别能够确保同一事务中的多次读取没有其他事务来修改值，解决了不可重复读取或不一致解析的问题，但是在第一次读取后，事务会保持它们的共享锁，因此对于当前共享锁锁住的值的更新都不会获得一个排他锁，即更新阻塞，这样就很有可能导致死锁，并且阻止更新冲突。
- 虽然 `repeatable read`  隔离级别可以确保在事务中第一次读取的行能够重复读取，但是事务锁定的资源（如行）是查询第一次运行时发现的，在查询运行时那里并没有的资源（如行）不会被锁定，因此同一事务中的第二次读取可能会返回新行，这些新行被称为幻影，这种读取称为幻影读取。如果在多次读取之间，另一个事务添加了读取者查询筛选限定的新行，就会导致幻影读取。


4. serializable隔离级别
为了防止幻影读取，需要将隔离级别提升为serializable，最重要的部分是serializable隔离级别的行为类似于 `repeatable read` 即它要求读取者获取一个共享锁来进行读取，并持有锁到事务结束，但是serializable隔离级别添加了另外一个方面-在逻辑上，该隔离级别要求读取者锁定查询筛选所限定的键的整个范围。这意味着读取者锁定的不仅是查询筛选限定的现有行，也包括将来行，或者准确地说，它会阻止其他事务尝试添加读取者查询筛选限定的行。

### 基于行版本的隔离级别

在sql server中存在两种基于行版本控制技术的隔离级别：snapshot、read committed snapshot。将提交行之前的版本存储在tempdb中，snapshot隔离级别在逻辑上类似于serializable隔离级别，read committed snapshot隔离级别类似于read committed隔离级别，但是，读取者使用基于行版本控制的隔离级别并不不会发出共享锁，所以在请求的数据以排他锁锁定时它们不会等待，读取者仍旧会获得类似于serializable和read  committed的一致性级别，如果当前版本不是它们希望看到的版本，那么sql server会给读取者提供一个较旧的版本。

如果启用了任何基于快照的隔离级别，在修改tempdb之前，delete和update语句需要复制行的版本，对于insert语句则不需要再tempdb中版本化，因为它不存在早期的版本，但需要注意的是，启用任何基于行版本控制的隔离级别对于数据更新和删除的性能可能会有负面影响，由于它们不会获取共享锁，并且哎数据被以排他方式锁定或是数据版本不是所期望的版本时不需要等待，因此对于读取者的性能通常会有所改善。

#### snapshot 隔离级别 ####
在snapshot隔离级别下，读取者在读取数据时， 它是确保获得事务启动时最近提交的可用行版本，这意味着，保证获得的是提交后的读取并且可重复读取，以及确保获得不是幻读，类似于serializable级别中一样，但是此隔离级别依赖于行版本，而不是使用共享锁，要想在企业部署的sql server实例中允许事务以snapshot隔离级别工作，首先需要在查询窗口执行以下代码打开快照隔离级别。如下：
```
alter database [database name] set allow_snapshot_isolation on
```

snapshot隔离级别可以防止更新冲突，但不会像 `repeatable read` 和serializable隔离级别那样产生死锁，snapshot隔离级别的事务失败，表明检测到了更新冲突，snapshot隔离级别通过检查存储的版本来检测更新冲突，它可以发现在事务的读取和写入之间是否有另一个事务修改了数据。

ps:
```
alter database [database name] set allow_snapshot_isolation on 
```
开启snapshot 只针对当前会话生效，在其他会话的查询需要``` set tran isolation level snapshot``

#### READ COMMITTED SNAPSHOT隔离级别 ####

该隔离级别也是基于行版本控制，它与SNAPSHOT隔离级别区别在于，读取者获得是【语句】启动时可用的最后提交的行版本，而不是【事务】启动时可用的最后提交的行版本，READ COMMITTED SNAOSHOT也不会检测更新冲突，导致类似于READ COMMITTED隔离级别，但在所请求资源被排他锁锁定时，不会请求共享锁并且不会等待，即可以直接查询不等待排它锁的释放。在企业内部部署的SQL Server中要想启动READ COMMITTED SNAPHOST隔离级别，需要打开**唯一**会话来设置，否则无法进行启用（启用该隔离级别实际上是将READ COMMITTED隔离级别在语义上改变为READ COMMITTED SNAPSHOT隔离级别）。开启 READ_COMMITTED_SNAPSHOT：
```
ALTER DATABASE [database name] SET READ_COMMITTED_SNAPSHOT ON;
```
PS:  这样设置是针对整个db的，所以跟 开启snapshot 不同，其他会话都会可以以 这种隔离级别查询。

通过 ``` DBCC USEROPTIONS``` 可以查询当前数据库的设置情况，包括 isolation level

可以解决在程序中 查询和update 在同一事务，且事务中的查询和update设计的表较多，多线程运行程序出现的死锁问题。
由于查询和update处于同一事务，例如```readWriteTrans ```  ， ```isolation level : read_committed```，所以查询也会有共享锁，当另外的线程要更新获取排它锁是处于等待，而共享锁是在事务结束后释放

