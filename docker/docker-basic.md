##Docker简介
Docker官网：http://www.docker.com

Github Docker源码：https://github.com/docker/docker

Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。

Docker 包括三个基本概念

镜像（Image）
容器（Container）
仓库（Repository）
理解了这三个概念，就理解了 Docker 的整个生命周期

---

##为什么要使用 `Docker`？
作为一种新兴的虚拟化方式，`Docker` 跟传统的虚拟化方式相比具有众多的优势。

###更高效的利用系统资源
由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销， `Docker` 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。

###更快速的启动时间
传统的虚拟机技术启动应用服务往往需要数分钟，而 `Docker` 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。

###一致的运行环境
开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 `bug` 并未在开发过程中被发现。而 `Docker` 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 *「这段代码在我机器上没问题啊」* 这类问题。

###持续交付和部署
对开发和运维（ `DevOps` ）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。

使用 `Docker` 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 `Dockerfile` 持续集成( `Continuous Integration` )来进行镜像构建，并结合持续部署( `Continuous Delivery/Deployment` )系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合系统进行自动部署。

而且使用 `Dockerfile` 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。

###更轻松的迁移
由于 `Docker` 确保了执行环境的一致性，使得应用的迁移更加容易。 `Docker` 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。

###更轻松的维护和扩展
`Docker` 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外， `Docker` 团队同各个开源项目团队一起维护了一大批高质量的官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。

###对比传统虚拟机总结
| 特性 |	容器|	虚拟机
|---------|---------|---------|
| 启动|	秒级|	分钟级
| 硬盘使用|	一般为MB|	一般为GB
| 性能|	接近原生|	弱于
| 系统支持量|	单机支持上千个容器|	一般几十个

---
##镜像（Image)
`Docker` 镜像是什么？

操作系统分为内核和用户空间。对于 `Linux` 而言，内核启动后，会挂在 `root` 文件系统为其提供用户空间支持。而 `Docker` 镜像( `Image` )，就相当于是一个 `root` 文件系统。比如官方镜像 `ubuntu:16.04` 就包含了完整的一套 `Ubuntu16.04` 最小系统的 `root` 文件系统。

`Docker` 镜像是一个特殊的文件系统，除了提供容器运行时候所需要的程序、库、资源、配置文件等，还包含了一些为运行准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。

镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。

镜像构建的时候，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只会发生在自己这一层。比如：删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。

分层存储的特征还使得镜像的复用和定制变得更容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。

通俗的讲，它是一个只读文件，类似于我们安装操作系统时候所需要的那个 `ios` 光盘镜像，通过运行这个镜像来完成各种应用的部署。

这里的镜像就是一个能被 `docker` 运行起来的程序。

###镜像指令

####搜索

`docker serach [image_name]`

####获取

`docker pull [image_name]`

####查看

`docker images <image_name>`

####列出本地所有镜像

`docker images`
或者
`docker images -a`


####镜像重命名

`docker tag [old_image]:[old_version] [new_image]:[new_version]`

####删除镜像

`docker rmi [image_id/image_name:image_version]`

####导出镜像

`docker save -o [包文件][镜像]`
`docker save [镜像1]...[镜像n] > [包文件]` # 会保存镜像的所有历史记录和元数据信息

####导入镜像

`docker load < [image.tar_name]`
`docker load -i [image.tar_name]`

####查看镜像历史

`docker history [image_name]`

---

##容器（Container）
镜像和容器的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时候的实体。容器可以被创建、启动、停止、删除和暂停等。

容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 `root` 文件系统、自己的网络配置、自己的进程空间，甚至可以应用自己的用户 `ID` 空间。容器内的进程是一个运行在隔离的环境里，使用起来就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比在直接宿主运行更加安全。也因为这种隔离的特性，初学 `Docker` 常常会混淆容器和虚拟机。

每一个容器运行的时候，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时候读写而准备的存储层为容器存储层。

容器存储层的生命周期和容器一样，容器消失时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随着容器的删除而丢失。

按照 `Docker` 最佳实践的要求，容器不应该向其存储层写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（ `Volume` ）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。

###容器指令

####查看容器

`docker ps`
或者 `docker container ls`
或者 `docker container ls -a`



####启动容器

#####以守护进程方式启动容器
`docker run [参数] docker_image [执行的命令]`
`docker run -d nginx`



`-t` 选项让 `Docker `分配一个伪终端并绑定到容器的标准输入上，
`-i` 则让容器的标准输入保持打开

`docker run -i -t nginx /bin/bash`

`–name` 选项来给容器设置一个名字

`docker run --name myubuntu -dit ubuntu`

#####启动已终止的容器
在生产过程中，会出现运行和不运行的容器，我们使用 `start` 命令开启一个已关闭的容器

`docker start [container_id]`

####关闭容器
在生产中，会因为临时情况，要关闭某些容器，使用 `stop` 命令来关闭某个容器

`docker stop [container_id]`

####删除容器
删除容器有两种方法：

正常删除 – 删除已关闭的

强制删除 – 删除正在运行的

#####正常删除容器
`docker rm [container_id]`

#####强制删除运行容器
`docker rm -f [container_id]`

#####拓展批量关闭容器
`docker rm -f $(docker ps -a -q)`

#####进入正在运行的容器
`docker exec [选项] 容器id/容器名 命令`

只用 `-i` 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。

当 `-i-t` 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符

`docker exec -it myubuntu /bin/bash`

####基于容器创建镜像
`docker commit -m '改动信息' -a "作者信息" container_id new_image:tag`

####查看容器详细信息
`docker inspect [容器id]`

####查看容器运行日志
`docker logs [容器id]`

---

##仓库（Repository）
镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务， `Docker Registry` 就是这样的服务。

一个 `Docker Registry` 中可以包含多个仓库（ `Repository` ）；每个仓库可以包含多个标签（ `Tag` ）；每个标签对应一个镜像。

通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 `<仓库名>:<标签>` 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 `latest` 作为默认标签。

以 `Ubuntu` 镜像 为例，`ubuntu` 是仓库的名字，其内包含有不同的版本标签，如，`16.04` , `18.04` 。我们可以通过 `ubuntu:14.04` ，或者 `ubuntu:18.04`  来具体指定所需哪个版本的镜像。如果忽略了标签，比如 `ubuntu` ，那将视为 `ubuntu:latest` 。

仓库名经常以 `两段式路径` 形式出现，比如 `jwilder/nginx-proxy` ，前者往往意味着 `Docker Registry` 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 `Docker Registry` 的软件或服务。

###公开仓库
Docker Registry`` 公开服务是开放给用户使用、允许用户管理镜像的 `Registry` 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。

最常使用的 `Registry` 公开服务是官方的 `Docker Hub`，这也是默认的 `Registry` ，并拥有大量的高质量的官方镜像。除此以外，还有 CoreOS 的 Quay.io，CoreOS 相关的镜像存储在这里；Google 的 Google Container Registry，Kubernetes 的镜像使用的就是这个服务。

由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 阿里云加速器、DaoCloud 加速器 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。

国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 时速云镜像仓库、网易云镜像服务、DaoCloud 镜像市场、阿里云镜像库 等。

###私有仓库
除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。在 私有仓库 一节中，会有进一步的搭建私有 Registry 服务的讲解。

开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 Docker Trusted Registry 中，提供了这些高级功能。

除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，VMWare Harbor 和 Sonatype Nexus。

---

##数据卷
数据卷是一个可供一个或多个容器使用的特殊目录，可以提供很多有用的特性：

数据卷可以在容器之间共享和重用
对数据卷的修改会立马生效
对数据卷的更新，不会影响镜像
数据卷默认会一直存在，即使容器被删除

###数据卷指令
关于数据卷的管理我们从两个方面来说：

1、目录

2、普通文件

####数据卷目录
`docker run -itd --name 容器名字 -v 宿主机目录:容器目录 镜像名称 [命令（可选)]`

####数据卷文件
`docker run -itd --name 容器名字 -v 宿主机文件:容器文件 镜像名称 [命令(可选)]`

####数据卷容器

1. 创建一个数据卷容器

`docker create -v 容器数据卷目录 --name 容器名字 镜像名称 [命令(可选)]`

2. 创建两个容器，同时挂在到刚创建的数据卷容器

`docker run --volumes-from 数据卷容器id/name -dit --name 容器名字 镜像名称 [命令(可选)]`

3. 此时进入到容器的 `bin/bash` 下 可以测试这个数据卷容器是否被两个容器共享

容器间可以共享数据卷容器，不过数据是保存在数据卷内，并没有保存到宿主机的文件目录中

---

##网络
默认情况下，容器和宿主机之间网络是隔离的，我们可以通过端口映射的方式，将容器中的端口，映射到宿主机的某个端口上。这样我们就可以通过宿主机的ip+port的方式来访问容器里的内容

###随机映射
容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过-P或-p参数来指定端口映射。

当使用 `-P` 标记时，`Docker` 会随机映射一个 `49000~49900` 的端口到内部容器开放的网络端口。

###默认随机映射
`docker run -d -P 镜像名称`

命令效果：

启动一个 nginx 镜像

`docker run -d -P nginx`

`-P` 自动绑定所有对外提供服务的容器端口，映射的端口将会从没有使用的端口池中自动随机选择，但是如果连续启动多个容器的话，则下一个容器的端口默认是当前容器占用端口号 `+1`

###指定主机随机映射
命令格式

`docker run -d -p 宿主机ip::容器端口 --name 容器名称 镜像名称`

命令效果

`docker run -d -p 192.168.229.128::80 --name nginx- nginx`

指定映射
`docker run -d -p 宿主机ip:宿主机端口:容器端口 --name 容器名字 镜像名称`

命令效果：

启动一个 nginx 镜像,我们在启动容器的时候，给容器指定一个访问的端口 1199

`docker run -d -p 192.168.229.128:1199:80 --name nginx nginx`

###多端口映射方法
命令格式

`docker run -d -p 宿主机端口1:容器端口1  -p 宿主机端口2:容器端口2 --name 容器名称 镜像名称`

###开起多端口映射实践

`docker run -d -p 520:443 -p 6666:80 --name nginx- nginx`

---

##Dockerfile进阶
Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。

###创建Dockerfile
在一个空白目录中，建立一个文本文件，并命名为Dockerfile：
```
$ mkdir mynginx
$ cd mynginx
$ touch Dockerfile
```

注意事项

>1、大： 首字母必须大写D
>2、空： 尽量将Dockerfile放在空目录中。
>3、单： 每个容器尽量只有一个功能。
>4、少： 执行的命令越少越好。

其内容为：

```
FROM nginx
RUN echo '<h1>Hello, Docker!</h1>' > /usr/share/nginx/html/index.html
```

这个 `Dockerfile` 很简单，一共就两行。涉及到了两条指令，`FROM` 和 `RUN` 

####FROM 指定基础镜像
所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个nginx镜像的容器，再进行修改一样，基础镜像是必须指定的。而FROM就是指定基础镜像，因此一个Dockerfile中FROM是必备的指令，并且必须是第一条指令。

##### `RUN` 执行命令
`RUN` 指令是用来执行命令行命令的。由于命令行的强大能力，`RUN` 指令在定制镜像时是最常用的指令之一。

`Dockerfile` 中每一个指令都会建立一层， `RUN` 也不例外。

##### 构建镜像
这里我们使用了 `docker build` 命令进行镜像构建。其格式为：

`docker build [选项] <上下文路径/URL/->`

在 `Dockerfile` 文件所在目录执行
```
$ docker build -t nginx:v3 .
```
`-t` 表示 imagename:tag

`.` 表示当前目录

查看效果
```
python@ubuntu:~/mynginx$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
nginx               v3                  a0c76822ec6d         seconds ago       109MB
nginx               latest              8c9ca4d17702         days ago          109MB
ubuntu              latest              47b19964fb50         weeks ago         88.1MB
registry            latest              d0eed8dad114         weeks ago         25.8MB
python@ubuntu:~/mynginx$ docker run -dit -p 192.168.119.128:1122:80 nginx:v3
5f855ca915ef17014ac10c8997f69f7acc9fcb684f6b2b92699c573d162aba88
python@ubuntu:~/mynginx$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                          NAMES
5f855ca915ef        nginx:v3            "nginx -g 'daemon of…"    seconds ago       Up  seconds        192.168.229.128:1122->80/tcp   elastic_proskuriakova
python@ubuntu:~/mynginx$ curl 192.168.229.128:1122
<h1>Hello, Docker!</h1>
```


#### CMD 容器启动命令
`CMD` 指令就是用于指定默认的容器主进程的启动命令的。

`CMD` 指令的格式和 `RUN` 相似，也是两种格式：


格式：

`CMD ["可执行文件", "参数1", "参数2"...]`

介绍容器的时候曾经说过， `Docker` 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。`CMD` 指令就是用于指定默认的容器主进程的启动命令的。

在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，`ubuntu` 镜像默认的 `CMD` 是 `/bin/bash` ，如果我们直接 `docker run -it ubuntu` 的话，会直接进入 `bash` 。我们也可以在运行时指定运行别的命令，如 `docker run -it ubuntu cat /etc/os-release` 。这就是用 `cat /etc/os-release` 命令替换了默认的 `/bin/bash` 命令了，输出了系统版本信息。

在指令格式上，一般推荐使用 `exec` 格式，这类格式在解析时会被解析为 `JSON` 数组，因此一定要使用双引号 `"`，而不要使用单引号。

提到 `CMD` 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。

`Docker` 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，容器内没有后台服务的概念。

对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。

#### `ENTRYPOINT` 入口点
设置容器启动时执行的命令

`ENTRYPOINT` 的格式和 `RUN` 指令格式一样，分为 `exec` 格式和 `shell` 格式。

`ENTRYPOINT` 的目的和 `CMD` 一样，都是在指定容器启动程序及参数。 `ENTRYPOINT` 在运行时也可以替代，不过比 `CMD` 要略显繁琐，需要通过 `docker run` 的参数 `--entrypoint` 来指定。

当指定了 `ENTRYPOINT` 后，`CMD` 的含义就发生了改变，不再是直接的运行其命令，而是将 `CMD` 的内容作为参数传给 `ENTRYPOINT` 指令，换句话说实际执行时，将变为：

`<ENTRYPOINT> "<CMD>"`

#### `EXPOSE` 声明端口指令
格式为
`EXPOSE <端口1> [<端口2>...]`

`EXPOSE` 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 `Dockerfile` 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 `docker run -P` 时，会自动随机映射 `EXPOSE` 的端口。

要将 `EXPOSE` 和在运行时使用 `-p <宿主端口>:<容器端口>` 区分开来。 `-p` ，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 `EXPOSE` 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。

#### WORKDIR 指定工作目录
格式为
`WORKDIR <工作目录路径>`

使用 `WORKDIR` 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，`WORKDIR` 会帮你建立目录。类似于 `Linux` 中的 `cd` 指令

例如：

`WORKDIR /root`
`WORKDIR /code`
`WORKDIR /django`
`RUN pwd`    
输出结果为 `/code/django`


>尽量使用绝对目录
>如果需要改变工作目录的位置，使用WORKDIR指令

#### `COPY` 复制文件
格式：

`COPY  <源路径>  <目标路径>`

`COPY` 指令将从构建上下文目录中<源路径>的文件/目录复制到新的一层的镜像内的<目标路径>位置。比如：

`COPY package.json /usr/src/app/`

此外，还需要注意一点，使用 `COPY` 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。

>单纯复制文件场景， `Docker` 推荐使用 ` COPY`

#### `ADD` 更高级的复制文件
`ADD` 指令和 `COPY` 的格式和性质基本一致。但是在 `COPY` 基础上增加了一些功能。

比如<源路径>可以是一个 `URL` ，这种情况下， `Docker` 引擎会试图去下载这个链接的文件放到<目标路径>去。下载后的文件权限自动设置为 `600`，如果这并不是想要的权限，那么还需要增加额外的一层 `RUN` 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 `RUN`指令进行解压缩。所以不如直接使用 `RUN`指令，然后使用 `wget`或者 `curl` 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。

#### VOLUME 定义匿名卷
格式为：

`VOLUME <路径>`

我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷( `volume` )中。

`VOLUME /data`

这里的 `/data` 目录就会在运行时，任何向 `/data` 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。

#### ENV 设置环境变量
格式：

`ENV <key> <value>`
或者
`ENV <key1>=<value1> <key2>=<value2>...`

这个指令很简单，就是设置环境变量而已，无论是其它指令，如RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。

`ENV NODE_VERSION 7..0`

`RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz"`

定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。

>尽量使用ENV增加可维护性